# Lectures 6 and 7 practice

## Задание 1

Задание про использование IORef и IOArray (также можно использовать [vector](https://hackage.haskell.org/package/vector) если есть желание).
Пишем на хаскеле в императивном стиле.

Реализуйте утилиту `sort` которая в качестве аргументов командной строки будет
принимать массив, который необходимо отсортировать и печатать отсортированный массив,
например:
```sh
stack exec -- sort 2 4 1 6 5 7
1 2 4 5 6 7
```

Это задание может быть сдано более чем одним человеком при условии, что разными людьми
будут реализованы разные сортировки. Сортировки должны быть in-place и не медленее,
чем O(nlogn).

## Задание 2

Задание про работу с файлами и аргументами командной строки.
Рекомендуется использовать [optparse-applicative](https://hackage.haskell.org/package/optparse-applicative)
для парсинга аргументов командной строки.

Реализовать простую утилиту для поддержания TODO-листа, она должна уметь:
* Добавить таску
* Изменить статус таски (open, in progress, done)
* Удалить таску
* Посмотреть на все таски с каким-либо статусом.

Например:
```sh
stack exec -- todo-list --add-task 'Придумать задания для практики'
```

## Задание 3

Задание про использование [`System.Process`](https://hackage.haskell.org/package/process-1.6.7.0/docs/System-Process.html)
и [`System.IO`](http://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html).

Реализовать утилиту, которая принимает в качестве аргумента путь до директории,
рекурсивно перебирает все файлы в директории и производит сравнение файлов на похожесть
попарно друг с другом. В качестве результата утилиты выводит наиболее похожие
файлы. Для сравнения похожести файлов можете использовать `diff` или другие аналоги.

Пример использования:
```sh
$ ls hw1_solutions
hw1_zyoba.hs hw1_zyaba.hs hw1_biba.hs hw1_boba.hs
$ stack exec -- diff-measurer hw1_solutions
Two most similar files: hw1_zyoba.hs hw1_boba.hs
```

## Задание 4

Задание про трансформеры.

Продолжаем развлекаться с eDSL.
Мы теперь знаем как комбинировать монады, поэтому готовы реализовать более-менее полноценный
игрушечный.

Необходимо реализовать функцию
```
evalStatement :: (???) => Statement a -> String
```
для eDSL, который является объединением 1-3 заданий из
[практики для пятой лекции](../lecture5-practice/README.md).

## Задание 5

Реализовать стековый строковой процессор. Его грамматика следующая:
* `push "string" : s -> String : s` положить строку на вершину стека.
* `read :: String {file} : s -> String : s` прочитать файл и положить содержимое
  на вершину стека.
* `slice <int> <int> :: String : s -> String : s`
* `concat :: String : String : s -> String : s`

Необходимо реализовать парсер и интерпретатор. Самостоятельно определите тип
для eDSL этого строкового процессора.

В конце работы интепретатора, вернуть строку с вершини стека, если стек размера 1,
и сообщить об ошибке, если размер стека не единичный.

В качестве среды необходимо использовать `ReaderT (IORef [Text]) IO`.

## Задание 6

Аналогично предыдущему, только в качестве среды исполнения необходимо использовать
`ReaderT (Map FilePath Text) (StateT [Text])`.
